# Spring Container
---
## Spring Container??
> 우리는 앞서 AppConfig(공연 기획자)에 대해 이미 배웠다.  
> AppConfig도 Spring Container의 일종이다. (Annotation 기반의 자바 설정 클래스)  
```java
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
```
- 이 때, ```ApplicationContext```가 Spring Container가 된다.

1. Create Spring Container  
![image](https://user-images.githubusercontent.com/71700079/148956338-2f69a52d-06cb-4731-b4bd-70066ae3492e.png)  

2. Spring Bean Register  
![image](https://user-images.githubusercontent.com/71700079/148956445-bd33064e-86db-450c-9c92-be0bb79b2ec1.png)  
- 여기서 Bean의 이름이 겹쳐버리면, 오류가 발생할 수가 있다.
- 따라서 반드시 Bean의 이름들은 다르게 부여할 것!

3. Dependancy Injection in Bean  
![image](https://user-images.githubusercontent.com/71700079/148956710-27782462-bb2b-4ef8-838e-82c24364e06d.png)  
- 우리가 미리 설계 해놓은 대로 의존 관계(Dependancy)를 주입한다.

## Web Application & Singleton
> 스프링은 대부분 Web Application이다.  
> Web Application은 보통 여러 고객이 동시에 요청을 하게 된다.  
> 이 때, 요청 시 마다 DI Container이 객체를 매번 생성하게 되면, 메모리에 객체의 수가 무한정으로 늘어나게 되어 버린다.  
> 이는 매우 심한 메모리의 낭비, 이 때 필요한 것이 __Singleton Pattern!__  

- 위에서 말했듯, 아무리 많은 요청이 들어와도 같은 클래스의 동일 Instance는 메모리에 1개만 생성됨을 보장하는 패턴이 __Singleton__ 이다.
- Singleton의 핵심은, ```Private``` Constructor을 통해 객체 Instance를 생성하는 ```new``` keyword를 함부로 못 쓰게 하는 것!
- 아래와 같이 Singleton 패턴을 구현할 수 있다.
```java
public class SingletonService {
    // 1. Static 영역에 단 하나의 객체만 생성한다.
    private static final SingletonService instance = new SingletonService();

    // 2.
    public static SingletonService getInstance(){
        return instance;
    }

    private SingletonService(){
    }

    public void logic(){
        System.out.println("싱글톤 객체 로직 호출");
    }
```
- 위의 SingletonService Class를 이용하여 Test Code를 작성 후 실행시켜보자.
```java
@Test
    @DisplayName("싱글톤 패턴을 적용한 객체 사용")
    public void singletonServiceTest(){
        SingletonService singleton1 = SingletonService.getInstance();
        SingletonService singleton2 = SingletonService.getInstance();

        System.out.println("singleton1 = " + singleton1);
        System.out.println("singleton2 = " + singleton2);

        Assertions.assertThat(singleton1).isSameAs(singleton2);
        singleton1.logic();
    }
```
![image](https://user-images.githubusercontent.com/71700079/149330478-777a05af-39a0-4bb4-9918-e3ec168125cf.png)  
- Test Code의 결과가 같은 주소 값을 반환한다.
- 이는 곧 하나의 객체만을 참조함을 알 수 있다!
